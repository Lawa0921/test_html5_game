# 2.5D 等角視圖場景實作計畫

## 概述

本文檔描述如何在 Phaser 3 中實作 2.5D 等角視圖（Isometric）場景系統，用於客棧經營遊戲。

## 技術架構

### 1. 場景層級結構

```
Scene 結構：
├── Background Layer (depth: 0)
│   └── 靜態場景底圖（2.5D 預渲染圖片）
├── Character Layer (depth: 動態)
│   ├── NPC sprites
│   ├── Player sprite
│   └── 動態物件
└── UI Layer (depth: 1000+)
    └── 介面元素
```

### 2. 深度排序系統（Z-ordering）

**原理**：在 2.5D 等角視圖中，Y 座標越大（越靠近畫面底部），物件應該顯示在越前面。

**實作方式**：
```javascript
// 每幀更新 sprite 的 depth
sprite.depth = sprite.y;

// 或使用更精細的計算
sprite.depth = sprite.y + (sprite.x * 0.0001); // 避免相同 Y 時的閃爍
```

**Phaser 自動排序**：
- Phaser 會根據 depth 值自動排序渲染順序
- depth 值越大，越後渲染（顯示在越上層）

### 3. 可行走區域系統

#### 方案 A：矩形區域（最簡單）

```javascript
// 定義可行走的矩形區域
walkableArea = {
    x: 100,
    y: 200,
    width: 800,
    height: 400
};

// 檢查點是否在區域內
function isWalkable(x, y) {
    return x >= walkableArea.x &&
           x <= walkableArea.x + walkableArea.width &&
           y >= walkableArea.y &&
           y <= walkableArea.y + walkableArea.height;
}
```

#### 方案 B：多邊形區域（推薦）

```javascript
// 定義複雜的可行走區域（多邊形頂點）
walkablePolygon = new Phaser.Geom.Polygon([
    { x: 100, y: 200 },
    { x: 900, y: 200 },
    { x: 800, y: 600 },
    { x: 200, y: 600 }
]);

// 檢查點是否在多邊形內
function isWalkable(x, y) {
    return Phaser.Geom.Polygon.Contains(walkablePolygon, x, y);
}
```

#### 方案 C：排除區域（障礙物）

```javascript
// 定義不可行走的區域（桌子、櫃台等）
obstacles = [
    { x: 300, y: 300, width: 100, height: 80 }, // 桌子
    { x: 500, y: 400, width: 150, height: 60 }  // 櫃台
];

function isWalkable(x, y) {
    // 先檢查是否在大區域內
    if (!isInMainArea(x, y)) return false;

    // 再檢查是否碰到障礙物
    for (const obstacle of obstacles) {
        if (isPointInRect(x, y, obstacle)) {
            return false;
        }
    }
    return true;
}
```

### 4. 點擊移動系統

#### 基礎實作（線性移動）

```javascript
// 監聽場景點擊
this.input.on('pointerdown', (pointer) => {
    const targetX = pointer.x;
    const targetY = pointer.y;

    // 檢查目標位置是否可行走
    if (isWalkable(targetX, targetY)) {
        moveCharacterTo(player, targetX, targetY);
    }
});

// 移動角色（使用 Tween）
function moveCharacterTo(character, targetX, targetY) {
    // 計算距離和時間
    const distance = Phaser.Math.Distance.Between(
        character.x, character.y,
        targetX, targetY
    );
    const duration = distance / character.speed * 1000; // 速度轉換為時間

    // 創建移動動畫
    this.tweens.add({
        targets: character,
        x: targetX,
        y: targetY,
        duration: duration,
        ease: 'Linear',
        onUpdate: () => {
            // 更新深度
            character.depth = character.y;

            // 播放行走動畫
            if (!character.anims.isPlaying) {
                character.play('walk');
            }
        },
        onComplete: () => {
            // 停止行走動畫
            character.play('idle');
        }
    });
}
```

#### 進階實作（繞過障礙物）

```javascript
// 使用 A* 尋路算法
function moveCharacterWithPathfinding(character, targetX, targetY) {
    // 1. 將場景劃分為網格
    // 2. 使用 A* 找到路徑
    // 3. 沿著路徑點移動

    const path = findPath(character.x, character.y, targetX, targetY);

    if (path.length > 0) {
        moveAlongPath(character, path);
    }
}
```

### 5. 碰撞檢測系統

#### 方案 A：簡單圓形碰撞

```javascript
// 檢查兩個角色是否碰撞
function checkCollision(sprite1, sprite2, radius = 30) {
    const distance = Phaser.Math.Distance.Between(
        sprite1.x, sprite1.y,
        sprite2.x, sprite2.y
    );
    return distance < radius;
}
```

#### 方案 B：使用 Phaser 物理系統

```javascript
// 在場景中啟用物理
this.physics.add.existing(player);
this.physics.add.existing(npc);

// 設定碰撞體大小（通常比 sprite 小）
player.body.setSize(40, 20); // 橢圓形碰撞體
player.body.setOffset(12, 44); // 調整碰撞體位置（腳部）

// 添加碰撞檢測
this.physics.add.collider(player, npc, () => {
    console.log('角色碰撞！');
});
```

### 6. 實作優先級

#### Phase 1：基礎系統（立即實作）

1. ✅ **深度排序**：`sprite.depth = sprite.y`
2. ✅ **簡單可行走區域**：使用矩形或多邊形
3. ✅ **點擊移動**：Tween 動畫
4. ✅ **基礎碰撞**：圓形碰撞檢測

**預估時間**：2-3 小時

#### Phase 2：改進系統（後續優化）

1. ⏳ **精確可行走區域**：為每個場景定義詳細的多邊形
2. ⏳ **動畫整合**：行走動畫、閒置動畫
3. ⏳ **互動區域**：可點擊的物件（桌子、櫃台）
4. ⏳ **角色對話**：點擊 NPC 觸發對話

**預估時間**：4-6 小時

#### Phase 3：進階功能（長期目標）

1. 🔮 **A* 尋路**：繞過障礙物
2. 🔮 **網格系統**：劃分場景為格子
3. 🔮 **多樓層**：樓梯系統
4. 🔮 **動態陰影**：根據光源投影

**預估時間**：8-12 小時

## 實作範例

### 場景基礎類別（BaseIsometricScene）

```javascript
class BaseIsometricScene extends Phaser.Scene {
    constructor(key) {
        super({ key });
        this.characters = [];
        this.walkableArea = null;
    }

    create() {
        // 1. 載入背景
        this.add.image(640, 360, 'scene-background').setDepth(0);

        // 2. 定義可行走區域
        this.setupWalkableArea();

        // 3. 添加角色
        this.setupCharacters();

        // 4. 啟用點擊移動
        this.setupClickToMove();

        // 5. 每幀更新深度
        this.events.on('update', this.updateDepthSorting, this);
    }

    setupWalkableArea() {
        // 定義可行走的多邊形區域
        this.walkableArea = new Phaser.Geom.Polygon([
            { x: 100, y: 200 },
            { x: 1180, y: 200 },
            { x: 1100, y: 600 },
            { x: 180, y: 600 }
        ]);

        // 可視化可行走區域（調試用）
        if (this.physics.world.drawDebug) {
            const graphics = this.add.graphics();
            graphics.lineStyle(2, 0x00ff00);
            graphics.strokePoints(this.walkableArea.points, true);
        }
    }

    setupCharacters() {
        // 添加主角
        this.player = this.add.sprite(640, 360, 'player');
        this.player.speed = 200; // 移動速度（像素/秒）
        this.characters.push(this.player);

        // 添加 NPC
        const npc = this.add.sprite(400, 300, 'npc');
        npc.speed = 150;
        this.characters.push(npc);
    }

    setupClickToMove() {
        this.input.on('pointerdown', (pointer) => {
            const x = pointer.x;
            const y = pointer.y;

            // 檢查是否可行走
            if (Phaser.Geom.Polygon.Contains(this.walkableArea, x, y)) {
                this.movePlayerTo(x, y);
            } else {
                console.log('不可行走的區域');
            }
        });
    }

    movePlayerTo(targetX, targetY) {
        // 停止當前移動
        this.tweens.killTweensOf(this.player);

        // 計算移動時間
        const distance = Phaser.Math.Distance.Between(
            this.player.x, this.player.y,
            targetX, targetY
        );
        const duration = (distance / this.player.speed) * 1000;

        // 創建移動動畫
        this.tweens.add({
            targets: this.player,
            x: targetX,
            y: targetY,
            duration: duration,
            ease: 'Linear',
            onStart: () => {
                this.player.play('player-walk', true);
            },
            onComplete: () => {
                this.player.play('player-idle', true);
            }
        });
    }

    updateDepthSorting() {
        // 更新所有角色的深度
        this.characters.forEach(character => {
            character.depth = character.y;
        });
    }
}
```

## 場景配置範例

### LobbyScene 可行走區域配置

```javascript
// 大廳場景的可行走區域
const LOBBY_WALKABLE_AREA = new Phaser.Geom.Polygon([
    { x: 150, y: 250 },  // 左上角
    { x: 1130, y: 250 }, // 右上角
    { x: 1050, y: 580 }, // 右下角
    { x: 230, y: 580 }   // 左下角
]);

// 障礙物（桌子、櫃台等）
const LOBBY_OBSTACLES = [
    { x: 400, y: 350, width: 120, height: 80, name: '圓桌' },
    { x: 700, y: 350, width: 120, height: 80, name: '方桌' },
    { x: 550, y: 200, width: 180, height: 60, name: '櫃台' }
];

// 互動區域（可點擊的物件）
const LOBBY_INTERACTIONS = [
    {
        x: 640, y: 230, radius: 50,
        name: '櫃台',
        action: () => showCounterUI()
    },
    {
        x: 460, y: 390, radius: 40,
        name: '圓桌',
        action: () => showTableMenu()
    }
];
```

## 最佳實踐

### 1. 效能優化

- 只更新螢幕內的角色深度
- 使用物件池管理角色 sprites
- 限制同時移動的角色數量

### 2. 調試工具

```javascript
// 顯示可行走區域
toggleWalkableAreaDebug() {
    if (!this.debugGraphics) {
        this.debugGraphics = this.add.graphics();
        this.debugGraphics.lineStyle(2, 0x00ff00, 0.5);
        this.debugGraphics.strokePoints(this.walkableArea.points, true);
        this.debugGraphics.setDepth(999);
    } else {
        this.debugGraphics.destroy();
        this.debugGraphics = null;
    }
}

// 顯示碰撞體
this.physics.world.drawDebug = true;
```

### 3. 資料驅動配置

將可行走區域、障礙物等配置存為 JSON：

```json
{
  "sceneName": "LobbyScene",
  "walkableArea": {
    "type": "polygon",
    "points": [
      [150, 250],
      [1130, 250],
      [1050, 580],
      [230, 580]
    ]
  },
  "obstacles": [
    {
      "type": "rect",
      "x": 400,
      "y": 350,
      "width": 120,
      "height": 80,
      "name": "圓桌"
    }
  ],
  "spawnPoints": {
    "player": { "x": 640, "y": 500 },
    "npc1": { "x": 300, "y": 400 }
  }
}
```

## 下一步行動

1. ✅ 創建 `IsometricSceneManager.js` 工具類
2. ✅ 修改 `LobbyScene.js` 使用新系統
3. ✅ 測試深度排序和點擊移動
4. ✅ 為每個場景定義可行走區域配置

## 參考資源

- [Phaser 3 深度排序文檔](https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.Components.Depth.html)
- [Phaser 3 Tween 系統](https://photonstorm.github.io/phaser3-docs/Phaser.Tweens.Tween.html)
- [等角視圖遊戲開發教程](https://gamedevelopment.tutsplus.com/series/create-an-isometric-game--cms-1081)
