# 2.5D ç­‰è§’è¦–åœ–å ´æ™¯å¯¦ä½œè¨ˆç•«

## æ¦‚è¿°

æœ¬æ–‡æª”æè¿°å¦‚ä½•åœ¨ Phaser 3 ä¸­å¯¦ä½œ 2.5D ç­‰è§’è¦–åœ–ï¼ˆIsometricï¼‰å ´æ™¯ç³»çµ±ï¼Œç”¨æ–¼å®¢æ£§ç¶“ç‡ŸéŠæˆ²ã€‚

## æŠ€è¡“æ¶æ§‹

### 1. å ´æ™¯å±¤ç´šçµæ§‹

```
Scene çµæ§‹ï¼š
â”œâ”€â”€ Background Layer (depth: 0)
â”‚   â””â”€â”€ éœæ…‹å ´æ™¯åº•åœ–ï¼ˆ2.5D é æ¸²æŸ“åœ–ç‰‡ï¼‰
â”œâ”€â”€ Character Layer (depth: å‹•æ…‹)
â”‚   â”œâ”€â”€ NPC sprites
â”‚   â”œâ”€â”€ Player sprite
â”‚   â””â”€â”€ å‹•æ…‹ç‰©ä»¶
â””â”€â”€ UI Layer (depth: 1000+)
    â””â”€â”€ ä»‹é¢å…ƒç´ 
```

### 2. æ·±åº¦æ’åºç³»çµ±ï¼ˆZ-orderingï¼‰

**åŸç†**ï¼šåœ¨ 2.5D ç­‰è§’è¦–åœ–ä¸­ï¼ŒY åº§æ¨™è¶Šå¤§ï¼ˆè¶Šé è¿‘ç•«é¢åº•éƒ¨ï¼‰ï¼Œç‰©ä»¶æ‡‰è©²é¡¯ç¤ºåœ¨è¶Šå‰é¢ã€‚

**å¯¦ä½œæ–¹å¼**ï¼š
```javascript
// æ¯å¹€æ›´æ–° sprite çš„ depth
sprite.depth = sprite.y;

// æˆ–ä½¿ç”¨æ›´ç²¾ç´°çš„è¨ˆç®—
sprite.depth = sprite.y + (sprite.x * 0.0001); // é¿å…ç›¸åŒ Y æ™‚çš„é–ƒçˆ
```

**Phaser è‡ªå‹•æ’åº**ï¼š
- Phaser æœƒæ ¹æ“š depth å€¼è‡ªå‹•æ’åºæ¸²æŸ“é †åº
- depth å€¼è¶Šå¤§ï¼Œè¶Šå¾Œæ¸²æŸ“ï¼ˆé¡¯ç¤ºåœ¨è¶Šä¸Šå±¤ï¼‰

### 3. å¯è¡Œèµ°å€åŸŸç³»çµ±

#### æ–¹æ¡ˆ Aï¼šçŸ©å½¢å€åŸŸï¼ˆæœ€ç°¡å–®ï¼‰

```javascript
// å®šç¾©å¯è¡Œèµ°çš„çŸ©å½¢å€åŸŸ
walkableArea = {
    x: 100,
    y: 200,
    width: 800,
    height: 400
};

// æª¢æŸ¥é»æ˜¯å¦åœ¨å€åŸŸå…§
function isWalkable(x, y) {
    return x >= walkableArea.x &&
           x <= walkableArea.x + walkableArea.width &&
           y >= walkableArea.y &&
           y <= walkableArea.y + walkableArea.height;
}
```

#### æ–¹æ¡ˆ Bï¼šå¤šé‚Šå½¢å€åŸŸï¼ˆæ¨è–¦ï¼‰

```javascript
// å®šç¾©è¤‡é›œçš„å¯è¡Œèµ°å€åŸŸï¼ˆå¤šé‚Šå½¢é ‚é»ï¼‰
walkablePolygon = new Phaser.Geom.Polygon([
    { x: 100, y: 200 },
    { x: 900, y: 200 },
    { x: 800, y: 600 },
    { x: 200, y: 600 }
]);

// æª¢æŸ¥é»æ˜¯å¦åœ¨å¤šé‚Šå½¢å…§
function isWalkable(x, y) {
    return Phaser.Geom.Polygon.Contains(walkablePolygon, x, y);
}
```

#### æ–¹æ¡ˆ Cï¼šæ’é™¤å€åŸŸï¼ˆéšœç¤™ç‰©ï¼‰

```javascript
// å®šç¾©ä¸å¯è¡Œèµ°çš„å€åŸŸï¼ˆæ¡Œå­ã€æ«ƒå°ç­‰ï¼‰
obstacles = [
    { x: 300, y: 300, width: 100, height: 80 }, // æ¡Œå­
    { x: 500, y: 400, width: 150, height: 60 }  // æ«ƒå°
];

function isWalkable(x, y) {
    // å…ˆæª¢æŸ¥æ˜¯å¦åœ¨å¤§å€åŸŸå…§
    if (!isInMainArea(x, y)) return false;

    // å†æª¢æŸ¥æ˜¯å¦ç¢°åˆ°éšœç¤™ç‰©
    for (const obstacle of obstacles) {
        if (isPointInRect(x, y, obstacle)) {
            return false;
        }
    }
    return true;
}
```

### 4. é»æ“Šç§»å‹•ç³»çµ±

#### åŸºç¤å¯¦ä½œï¼ˆç·šæ€§ç§»å‹•ï¼‰

```javascript
// ç›£è½å ´æ™¯é»æ“Š
this.input.on('pointerdown', (pointer) => {
    const targetX = pointer.x;
    const targetY = pointer.y;

    // æª¢æŸ¥ç›®æ¨™ä½ç½®æ˜¯å¦å¯è¡Œèµ°
    if (isWalkable(targetX, targetY)) {
        moveCharacterTo(player, targetX, targetY);
    }
});

// ç§»å‹•è§’è‰²ï¼ˆä½¿ç”¨ Tweenï¼‰
function moveCharacterTo(character, targetX, targetY) {
    // è¨ˆç®—è·é›¢å’Œæ™‚é–“
    const distance = Phaser.Math.Distance.Between(
        character.x, character.y,
        targetX, targetY
    );
    const duration = distance / character.speed * 1000; // é€Ÿåº¦è½‰æ›ç‚ºæ™‚é–“

    // å‰µå»ºç§»å‹•å‹•ç•«
    this.tweens.add({
        targets: character,
        x: targetX,
        y: targetY,
        duration: duration,
        ease: 'Linear',
        onUpdate: () => {
            // æ›´æ–°æ·±åº¦
            character.depth = character.y;

            // æ’­æ”¾è¡Œèµ°å‹•ç•«
            if (!character.anims.isPlaying) {
                character.play('walk');
            }
        },
        onComplete: () => {
            // åœæ­¢è¡Œèµ°å‹•ç•«
            character.play('idle');
        }
    });
}
```

#### é€²éšå¯¦ä½œï¼ˆç¹ééšœç¤™ç‰©ï¼‰

```javascript
// ä½¿ç”¨ A* å°‹è·¯ç®—æ³•
function moveCharacterWithPathfinding(character, targetX, targetY) {
    // 1. å°‡å ´æ™¯åŠƒåˆ†ç‚ºç¶²æ ¼
    // 2. ä½¿ç”¨ A* æ‰¾åˆ°è·¯å¾‘
    // 3. æ²¿è‘—è·¯å¾‘é»ç§»å‹•

    const path = findPath(character.x, character.y, targetX, targetY);

    if (path.length > 0) {
        moveAlongPath(character, path);
    }
}
```

### 5. ç¢°æ’æª¢æ¸¬ç³»çµ±

#### æ–¹æ¡ˆ Aï¼šç°¡å–®åœ“å½¢ç¢°æ’

```javascript
// æª¢æŸ¥å…©å€‹è§’è‰²æ˜¯å¦ç¢°æ’
function checkCollision(sprite1, sprite2, radius = 30) {
    const distance = Phaser.Math.Distance.Between(
        sprite1.x, sprite1.y,
        sprite2.x, sprite2.y
    );
    return distance < radius;
}
```

#### æ–¹æ¡ˆ Bï¼šä½¿ç”¨ Phaser ç‰©ç†ç³»çµ±

```javascript
// åœ¨å ´æ™¯ä¸­å•Ÿç”¨ç‰©ç†
this.physics.add.existing(player);
this.physics.add.existing(npc);

// è¨­å®šç¢°æ’é«”å¤§å°ï¼ˆé€šå¸¸æ¯” sprite å°ï¼‰
player.body.setSize(40, 20); // æ©¢åœ“å½¢ç¢°æ’é«”
player.body.setOffset(12, 44); // èª¿æ•´ç¢°æ’é«”ä½ç½®ï¼ˆè…³éƒ¨ï¼‰

// æ·»åŠ ç¢°æ’æª¢æ¸¬
this.physics.add.collider(player, npc, () => {
    console.log('è§’è‰²ç¢°æ’ï¼');
});
```

### 6. å¯¦ä½œå„ªå…ˆç´š

#### Phase 1ï¼šåŸºç¤ç³»çµ±ï¼ˆç«‹å³å¯¦ä½œï¼‰

1. âœ… **æ·±åº¦æ’åº**ï¼š`sprite.depth = sprite.y`
2. âœ… **ç°¡å–®å¯è¡Œèµ°å€åŸŸ**ï¼šä½¿ç”¨çŸ©å½¢æˆ–å¤šé‚Šå½¢
3. âœ… **é»æ“Šç§»å‹•**ï¼šTween å‹•ç•«
4. âœ… **åŸºç¤ç¢°æ’**ï¼šåœ“å½¢ç¢°æ’æª¢æ¸¬

**é ä¼°æ™‚é–“**ï¼š2-3 å°æ™‚

#### Phase 2ï¼šæ”¹é€²ç³»çµ±ï¼ˆå¾ŒçºŒå„ªåŒ–ï¼‰

1. â³ **ç²¾ç¢ºå¯è¡Œèµ°å€åŸŸ**ï¼šç‚ºæ¯å€‹å ´æ™¯å®šç¾©è©³ç´°çš„å¤šé‚Šå½¢
2. â³ **å‹•ç•«æ•´åˆ**ï¼šè¡Œèµ°å‹•ç•«ã€é–’ç½®å‹•ç•«
3. â³ **äº’å‹•å€åŸŸ**ï¼šå¯é»æ“Šçš„ç‰©ä»¶ï¼ˆæ¡Œå­ã€æ«ƒå°ï¼‰
4. â³ **è§’è‰²å°è©±**ï¼šé»æ“Š NPC è§¸ç™¼å°è©±

**é ä¼°æ™‚é–“**ï¼š4-6 å°æ™‚

#### Phase 3ï¼šé€²éšåŠŸèƒ½ï¼ˆé•·æœŸç›®æ¨™ï¼‰

1. ğŸ”® **A* å°‹è·¯**ï¼šç¹ééšœç¤™ç‰©
2. ğŸ”® **ç¶²æ ¼ç³»çµ±**ï¼šåŠƒåˆ†å ´æ™¯ç‚ºæ ¼å­
3. ğŸ”® **å¤šæ¨“å±¤**ï¼šæ¨“æ¢¯ç³»çµ±
4. ğŸ”® **å‹•æ…‹é™°å½±**ï¼šæ ¹æ“šå…‰æºæŠ•å½±

**é ä¼°æ™‚é–“**ï¼š8-12 å°æ™‚

## å¯¦ä½œç¯„ä¾‹

### å ´æ™¯åŸºç¤é¡åˆ¥ï¼ˆBaseIsometricSceneï¼‰

```javascript
class BaseIsometricScene extends Phaser.Scene {
    constructor(key) {
        super({ key });
        this.characters = [];
        this.walkableArea = null;
    }

    create() {
        // 1. è¼‰å…¥èƒŒæ™¯
        this.add.image(640, 360, 'scene-background').setDepth(0);

        // 2. å®šç¾©å¯è¡Œèµ°å€åŸŸ
        this.setupWalkableArea();

        // 3. æ·»åŠ è§’è‰²
        this.setupCharacters();

        // 4. å•Ÿç”¨é»æ“Šç§»å‹•
        this.setupClickToMove();

        // 5. æ¯å¹€æ›´æ–°æ·±åº¦
        this.events.on('update', this.updateDepthSorting, this);
    }

    setupWalkableArea() {
        // å®šç¾©å¯è¡Œèµ°çš„å¤šé‚Šå½¢å€åŸŸ
        this.walkableArea = new Phaser.Geom.Polygon([
            { x: 100, y: 200 },
            { x: 1180, y: 200 },
            { x: 1100, y: 600 },
            { x: 180, y: 600 }
        ]);

        // å¯è¦–åŒ–å¯è¡Œèµ°å€åŸŸï¼ˆèª¿è©¦ç”¨ï¼‰
        if (this.physics.world.drawDebug) {
            const graphics = this.add.graphics();
            graphics.lineStyle(2, 0x00ff00);
            graphics.strokePoints(this.walkableArea.points, true);
        }
    }

    setupCharacters() {
        // æ·»åŠ ä¸»è§’
        this.player = this.add.sprite(640, 360, 'player');
        this.player.speed = 200; // ç§»å‹•é€Ÿåº¦ï¼ˆåƒç´ /ç§’ï¼‰
        this.characters.push(this.player);

        // æ·»åŠ  NPC
        const npc = this.add.sprite(400, 300, 'npc');
        npc.speed = 150;
        this.characters.push(npc);
    }

    setupClickToMove() {
        this.input.on('pointerdown', (pointer) => {
            const x = pointer.x;
            const y = pointer.y;

            // æª¢æŸ¥æ˜¯å¦å¯è¡Œèµ°
            if (Phaser.Geom.Polygon.Contains(this.walkableArea, x, y)) {
                this.movePlayerTo(x, y);
            } else {
                console.log('ä¸å¯è¡Œèµ°çš„å€åŸŸ');
            }
        });
    }

    movePlayerTo(targetX, targetY) {
        // åœæ­¢ç•¶å‰ç§»å‹•
        this.tweens.killTweensOf(this.player);

        // è¨ˆç®—ç§»å‹•æ™‚é–“
        const distance = Phaser.Math.Distance.Between(
            this.player.x, this.player.y,
            targetX, targetY
        );
        const duration = (distance / this.player.speed) * 1000;

        // å‰µå»ºç§»å‹•å‹•ç•«
        this.tweens.add({
            targets: this.player,
            x: targetX,
            y: targetY,
            duration: duration,
            ease: 'Linear',
            onStart: () => {
                this.player.play('player-walk', true);
            },
            onComplete: () => {
                this.player.play('player-idle', true);
            }
        });
    }

    updateDepthSorting() {
        // æ›´æ–°æ‰€æœ‰è§’è‰²çš„æ·±åº¦
        this.characters.forEach(character => {
            character.depth = character.y;
        });
    }
}
```

## å ´æ™¯é…ç½®ç¯„ä¾‹

### LobbyScene å¯è¡Œèµ°å€åŸŸé…ç½®

```javascript
// å¤§å»³å ´æ™¯çš„å¯è¡Œèµ°å€åŸŸ
const LOBBY_WALKABLE_AREA = new Phaser.Geom.Polygon([
    { x: 150, y: 250 },  // å·¦ä¸Šè§’
    { x: 1130, y: 250 }, // å³ä¸Šè§’
    { x: 1050, y: 580 }, // å³ä¸‹è§’
    { x: 230, y: 580 }   // å·¦ä¸‹è§’
]);

// éšœç¤™ç‰©ï¼ˆæ¡Œå­ã€æ«ƒå°ç­‰ï¼‰
const LOBBY_OBSTACLES = [
    { x: 400, y: 350, width: 120, height: 80, name: 'åœ“æ¡Œ' },
    { x: 700, y: 350, width: 120, height: 80, name: 'æ–¹æ¡Œ' },
    { x: 550, y: 200, width: 180, height: 60, name: 'æ«ƒå°' }
];

// äº’å‹•å€åŸŸï¼ˆå¯é»æ“Šçš„ç‰©ä»¶ï¼‰
const LOBBY_INTERACTIONS = [
    {
        x: 640, y: 230, radius: 50,
        name: 'æ«ƒå°',
        action: () => showCounterUI()
    },
    {
        x: 460, y: 390, radius: 40,
        name: 'åœ“æ¡Œ',
        action: () => showTableMenu()
    }
];
```

## æœ€ä½³å¯¦è¸

### 1. æ•ˆèƒ½å„ªåŒ–

- åªæ›´æ–°è¢å¹•å…§çš„è§’è‰²æ·±åº¦
- ä½¿ç”¨ç‰©ä»¶æ± ç®¡ç†è§’è‰² sprites
- é™åˆ¶åŒæ™‚ç§»å‹•çš„è§’è‰²æ•¸é‡

### 2. èª¿è©¦å·¥å…·

```javascript
// é¡¯ç¤ºå¯è¡Œèµ°å€åŸŸ
toggleWalkableAreaDebug() {
    if (!this.debugGraphics) {
        this.debugGraphics = this.add.graphics();
        this.debugGraphics.lineStyle(2, 0x00ff00, 0.5);
        this.debugGraphics.strokePoints(this.walkableArea.points, true);
        this.debugGraphics.setDepth(999);
    } else {
        this.debugGraphics.destroy();
        this.debugGraphics = null;
    }
}

// é¡¯ç¤ºç¢°æ’é«”
this.physics.world.drawDebug = true;
```

### 3. è³‡æ–™é©…å‹•é…ç½®

å°‡å¯è¡Œèµ°å€åŸŸã€éšœç¤™ç‰©ç­‰é…ç½®å­˜ç‚º JSONï¼š

```json
{
  "sceneName": "LobbyScene",
  "walkableArea": {
    "type": "polygon",
    "points": [
      [150, 250],
      [1130, 250],
      [1050, 580],
      [230, 580]
    ]
  },
  "obstacles": [
    {
      "type": "rect",
      "x": 400,
      "y": 350,
      "width": 120,
      "height": 80,
      "name": "åœ“æ¡Œ"
    }
  ],
  "spawnPoints": {
    "player": { "x": 640, "y": 500 },
    "npc1": { "x": 300, "y": 400 }
  }
}
```

## ä¸‹ä¸€æ­¥è¡Œå‹•

1. âœ… å‰µå»º `IsometricSceneManager.js` å·¥å…·é¡
2. âœ… ä¿®æ”¹ `LobbyScene.js` ä½¿ç”¨æ–°ç³»çµ±
3. âœ… æ¸¬è©¦æ·±åº¦æ’åºå’Œé»æ“Šç§»å‹•
4. âœ… ç‚ºæ¯å€‹å ´æ™¯å®šç¾©å¯è¡Œèµ°å€åŸŸé…ç½®

## åƒè€ƒè³‡æº

- [Phaser 3 æ·±åº¦æ’åºæ–‡æª”](https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.Components.Depth.html)
- [Phaser 3 Tween ç³»çµ±](https://photonstorm.github.io/phaser3-docs/Phaser.Tweens.Tween.html)
- [ç­‰è§’è¦–åœ–éŠæˆ²é–‹ç™¼æ•™ç¨‹](https://gamedevelopment.tutsplus.com/series/create-an-isometric-game--cms-1081)
